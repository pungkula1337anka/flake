#!/usr/bin/env bash

# Define colors
RED="\e[31m"
GREEN="\e[32m"
YELLOW="\e[33m"
BLUE="\e[34m"
MAGENTA="\e[35m"
CYAN="\e[36m"
ENDCOLOR="\e[0m"

# Display the logo
echo -e "$YELLOW
██████╗ ██╗   ██╗███╗   ██╗ ██████╗ ██╗  ██╗██╗   ██╗██╗      █████╗ 
██╔══██╗██║   ██║████╗  ██║██╔════╝ ██║ ██╔╝██║   ██║██║     ██╔══██╗
██████╔╝██║   ██║██╔██╗ ██║██║  ███╗█████╔╝ ██║   ██║██║     ███████║
██╔═══╝ ██║   ██║██║╚██╗██║██║   ██║██╔═██╗ ██║   ██║██║     ██╔══██║
██║     ╚██████╔╝██║ ╚████║╚██████╔╝██║  ██╗╚██████╔╝███████╗██║  ██║
╚═╝      ╚═════╝ ╚═╝  ╚═══╝ ╚═════╝ ╚═╝  ╚═╝ ╚═════╝ ╚══════╝╚═╝  ╚═╝
$ENDCOLOR"
echo -e "$BLUE https://github.com/pungkula1337anka $ENDCOLOR"
echo

# Run 'invoke --list' and color the output dynamically
invoke --list | while IFS= read -r line; do
    # Check if the line matches a task line (by looking for the format `task_name   description`)
    if [[ "$line" =~ ^\w+\ +\w+ ]]; then
        # Split the task name and description
        task_name=$(echo "$line" | awk '{print $1}')
        description=$(echo "$line" | sed 's/^[^ ]* //')
        
        # Colorize task name and description
        echo -e "${CYAN}$task_name${ENDCOLOR}   $description"
    else
        # For non-task lines, print them as they are (e.g., headers, empty lines)
        echo "$line"
    fi
done

